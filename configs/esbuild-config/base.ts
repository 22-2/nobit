// build.ts

import process from "process";
import { glob } from "glob";
import esbuild, { type BuildOptions } from "esbuild";

// --- å®šæ•°ã¨ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° ---

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

/**
 * ãƒ“ãƒ«ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã‚’æ±ºå®šã—ã¾ã™ã€‚
 * process.argv[2] ãŒ 'production' ã§ã‚ã‚Œã° 'production'ã€ãã‚Œä»¥å¤–ã¯ 'development' ã‚’è¿”ã—ã¾ã™ã€‚
 * @returns {'production' | 'development'} ãƒ“ãƒ«ãƒ‰ãƒ¢ãƒ¼ãƒ‰
 */
const getBuildMode = (): "production" | "development" => {
    return process.argv[2] === "production" ? "production" : "development";
};

/**
 * esbuildã®ãƒ™ãƒ¼ã‚¹è¨­å®šã‚’ç”Ÿæˆã—ã¾ã™ã€‚
 * @param mode ãƒ“ãƒ«ãƒ‰ãƒ¢ãƒ¼ãƒ‰
 * @returns esbuildã®å…±é€šè¨­å®šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
 */
const createBaseConfig = (mode: "production" | "development"): BuildOptions => {
    const isProd = mode === "production";
    return {
        banner: { js: banner },
        logLevel: "info",
        minify: isProd,
        sourcemap: isProd ? false : "inline",
        treeShaking: true,
    };
};

// --- ãƒ¡ã‚¤ãƒ³ãƒ“ãƒ«ãƒ‰ã‚¹ã‚¯ãƒªãƒ—ãƒˆ ---

/**
 * ãƒ“ãƒ«ãƒ‰ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³
 */
export interface RunBuildOptions {
    /** ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ (globãƒ‘ã‚¿ãƒ¼ãƒ³ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã®é…åˆ—) */
    entryPoints: string | string[];
    /** å‡ºåŠ›å…ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 'dist') */
    outdir?: string;
    /** ãƒ“ãƒ«ãƒ‰ãƒ¢ãƒ¼ãƒ‰ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: process.argvã‹ã‚‰æ±ºå®š) */
    mode?: "production" | "development";
    /** esbuildã®ãƒ“ãƒ«ãƒ‰ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ä¸Šæ›¸ããƒ»è¿½åŠ ã™ã‚‹ */
    override?: BuildOptions;
}

/**
 * CJSã¨ESMã®ä¸¡å½¢å¼ã§ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ãƒ“ãƒ«ãƒ‰ã™ã‚‹å…±é€šé–¢æ•°ã€‚
 *
 * é–‹ç™ºãƒ¢ãƒ¼ãƒ‰ã§ã¯watchãƒ¢ãƒ¼ãƒ‰ã§èµ·å‹•ã—ã€æœ¬ç•ªãƒ¢ãƒ¼ãƒ‰ã§ã¯1å›ã ã‘ãƒ“ãƒ«ãƒ‰ã—ã¦çµ‚äº†ã—ã¾ã™ã€‚
 *
 * @param options ãƒ“ãƒ«ãƒ‰ã‚ªãƒ—ã‚·ãƒ§ãƒ³
 */
export async function runBuild({
    entryPoints: entryPointsPattern,
    outdir = "dist",
    mode = getBuildMode(),
    override = {},
}: RunBuildOptions) {
    try {
        const isProd = mode === "production";
        const baseConfig = createBaseConfig(mode);

        // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆã‚’globãƒ‘ã‚¿ãƒ¼ãƒ³ã‹ã‚‰è§£æ±º
        const entryPoints = await getEntryPoints(entryPointsPattern);

        if (entryPoints.length === 0) {
            console.log("â„¹ï¸ No entry points found. Exiting.");
            return; // ãƒ—ãƒ­ã‚»ã‚¹ã‚’çµ‚äº†ã™ã‚‹ä»£ã‚ã‚Šã«æ­£å¸¸ã«ãƒªã‚¿ãƒ¼ãƒ³
        }

        console.log(`ğŸ“¦ Building for ${mode}...`);
        console.log("ğŸ“‚ Entry points:", entryPoints);
        console.log("ğŸ“¤ Output directory:", outdir);

        // å…¨ã¦ã®ãƒ“ãƒ«ãƒ‰å½¢å¼ã§å…±é€šã®è¨­å®š
        const sharedConfig: BuildOptions = {
            ...baseConfig,
            entryPoints,
            bundle: true,
            target: "esnext",
            ...override, // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹ä¸Šæ›¸ãã‚’é©ç”¨
        };

        // ãƒ“ãƒ«ãƒ‰ã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼ˆCJS, ESMï¼‰ã”ã¨ã®å€‹åˆ¥è¨­å®š
        const targets: BuildOptions[] = [
            {
                format: "cjs",
                outdir,
                outExtension: { ".js": ".js" },
            },
            {
                format: "esm",
                outdir,
                outExtension: { ".js": ".mjs" },
            },
        ];

        // å„ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ãƒ“ãƒ«ãƒ‰ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¸¦è¡Œã—ã¦ä½œæˆ
        const contexts = await Promise.all(
            targets.map((targetOptions) =>
                esbuild.context({ ...sharedConfig, ...targetOptions })
            )
        );

        if (isProd) {
            // æœ¬ç•ªãƒ“ãƒ«ãƒ‰ï¼š1å›ã ã‘å®Ÿè¡Œã—ã¦çµ‚äº†
            console.log("ğŸš€ Running production build...");
            await Promise.all(contexts.map((ctx) => ctx.rebuild()));
            await Promise.all(contexts.map((ctx) => ctx.dispose()));
            console.log("âœ… Build complete.");
        } else {
            // é–‹ç™ºãƒ“ãƒ«ãƒ‰ï¼šwatchãƒ¢ãƒ¼ãƒ‰ã§èµ·å‹•
            console.log("ğŸ‘€ Watching for changes...");
            await Promise.all(contexts.map((ctx) => ctx.watch()));
        }
    } catch (e) {
        console.error("âŒ Build failed:", e);
        process.exit(1);
    }
}

// --- ä½¿ç”¨ä¾‹ ---
// ã“ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ package.json ã‹ã‚‰å®Ÿè¡Œã™ã‚‹å ´åˆ
// "scripts": {
//   "dev": "node build.ts",
//   "build": "node build.ts production"
// }
// if (require.main === module) {
//   runBuild({
//     entryPoints: ["src/index.ts"],
//   });
// }

export async function getEntryPoints(
    pattarns: string[] | string
): Promise<string[]> {
    if (Array.isArray(pattarns)) {
        const results = await Promise.all(
            pattarns.map((pat) => getEntryPoints(pat))
        );
        return results.flat();
    } else {
        return glob(pattarns);
    }
}
